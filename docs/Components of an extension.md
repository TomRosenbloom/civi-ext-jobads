# Components of an extension

covered here: https://docs.civicrm.org/dev/en/latest/extensions/structure/

To get a better understanding of what these components are, let's put them in the order they are created, when creating a CRUD entity...

## The basic framework

`civix generate:module myextension` 

Creates:

- **info.xml**
- **myextension.php**
- **myextension.civix.php**
- **README.md**
- **LICENSE.txt**
- *build*
- *CRM/MyExtension*
- **images/screenshot.jpg**
- *templates*
- *xml*

Note that the folders created here are mostly empty (italics).

This could be a good time to update a few things in [info.xml](https://docs.civicrm.org/dev/en/latest/extensions/info-xml/) - name, description and author of the extension.



## The entity

`civix generate:entity MyEntity`

Updates:

- info.xml - adds entity-types 'mixin'

Creates:

- *api/v3*
- **Civi/Api4/Myentity.php**
- **CRM/Myentity/BAO/Myentity.php**
- *CRM/Myentity/DAO*
- **tests/phpunit/bootstrap.php**
- *tests/phpunit/api/v3*
- **xml/schema/CRM/Myentity/Myentity.entityType.php**
- **xml/schema/CRM/Myentity/Myentity.xml**

At this point it would be typical to make some manual changes to `xml/schema/CRM/Myentity/Myentity.xml`, which is the file that declares/defines the structure of your entity. This is for the most part a declaration of the structure and properties of the SQL table that will be used to store your entity items. So the root tag is 'table', and that contains tags like 'name' (the name the table will be given in SQL), a couple of 'field' tags, and tags defining primary keys, foreign keys. In the initial form generated by civix, there are just two field tags, one for the id of this entity and one for contact id. Also primary key, defined as the id, and foreign key, linking the contact id field to the civicrm_contact table (note the primaryKey and foreignKey tags are not nested but placed next to the fields they relate to). Of course these two 'starter' fields aren't of any great use on their own, and that's why you would normally add some new fields at this stage.

For **one-to-one** data, which will be stored in the same table, you add these as `<field>` tags, fully defined here in MyEntity.xml, but for **one-to-many** [and many-to-many?] the standard/default method is to first define an Option Group via the CiviCRM interface (under Administer->System Settings), then use the generated name of that option group in the field definition. More about this below, under 'Define an option group'.

Example of one-to-one data definition:

```xml
  <field>
    <name>description</name>
    <title>Full description</title>
    <type>longtext</type>
    <comment>Full description</comment>
    <html>
      <type>RichTextEditor</type>
      <rows>8</rows>
      <cols>60</cols>
    </html>
  </field>
```





## The entity boilerplate

`civix generate:entity-boilerplate`

Creates:

- **CRM/Myentity/DAO/JobAd.php** - this is your extension's local implementation of CiviCRM's core data access object (DAO) class(es) https://docs.civicrm.org/dev/en/latest/framework/codebase/#dao
- **sql/auto_install.sql** - https://docs.civicrm.org/dev/en/latest/framework/codebase/#sql
- **sql/auto_uninstall.sql**

[NB Civix will report having written to myentity.civix.php but don't be misled - this file hasn't been changed, but has been re-written the same as before. Civix re-writes this file every time]

Civix will point out you don't have an upgrader class.



## The upgrader class

`civix generate:upgrader`

Updates:

- info.xml - adds `<upgrader>CRM_Myentity_Upgrader</upgrader>`

Creates:

- **CRM/Myentity/Upgrader.php**

https://docs.civicrm.org/dev/en/latest/step-by-step/create-entity/#5-add-upgrader-class

"We need an upgrader class so that upon installation and uninstallation of our extension the files `auto_install.sql` and `auto_unsinstall.sql` are executed."

Now everything is in place, and we can install the extension, with `cv en myentity`. Now if we check the extensions page we'll see that the extension is installed (it would have already been listed, but not installed). We'll also find that there is a table civicrm_myentity in our database, and that Myentity is available in the APIv4 UI. We can now use the API UI to `create` a record in the civicrm_myentity table, then `get`, `delete` etc.

 

[at this stage we can make a SK search for our entity, and note there will be update and delete paths available when we make a table display... ]

[add and update paths - these are (or can be) added manually to xml/schema/CRM/Myentity/MyEntity.xml, and then they appear in CRM/Myentity/DAO/MyEntity.php - but is that neccessary? I did that for jobads, but in 'foo' they have appeared automatically at some stage (?) And the delete path? I had trouble with that in JobAds, but it seems to have appeared automatically in the UI for foo, but is not defined in either of these files (!?)]



## Install the extension

`cv en myentity`



Now we should see the following effects in the UI:

- the new extension appears as 'Enabled' under Administration->Customise Data & Screens->Extensions [is this the normal location?]
- the entity can be found in Api Explorer
- you can use the Api Explorer to perform CRUD actions on the entity
  - when you Create and Update, you'll see the fields as you defined in myentity.xml




If we are creating a new entity, we've just followed the first iteration of a cycle:

1) update entity schema 
2) generate boilerplate 
3) generate upgrader
4) (re-)install

This cycle will be repeated for any subsequent changes to the entity schema. [actually only the first two - just those followed by cv flush will do it]



What next? Whilst we can now perform CRUD actions through the API UI, that's not very user-friendly - only really suitable for advanced CiviCRM users. What we want now is to build into our extension some bespoke CRUD components suitable for non-technical users:

- searches and displays to view our entity data
- forms to create and update entity data

We might want different versions of these components for different users and different contexts:

- a search display a contact summary tab, showing data related to that contact only
- an admin front end
- public facing views

We might want to add some navigation links to appear in the Civi interface.

We will also want to ensure that our extension is properly self-contained and portable - all its components and dependencies are defined within the extension.



## Define some 'managed entities'

Managed Entity is a general concept, but in the scope of this document there are two particular sorts of managed entity that will interest us. These are, in no particular order, saved searches, and option groups.

Saved searches and option groups, as examples of managed entities, are created in a very similar way. Note your extension can define option groups but no saved search(es), or a saved search and no option groups. Saved searches and Option Groups are two independent varieties of managed entity.

The basic principle for creating managed entities is:  

1. create in UI
2. export code
3. insert code in extension
4. flush caches



### Defining an option group

1. Create an option group via the UI.
2. Export with API UI [in Voscur I have to do this manually because it's an older version, but in latest Civi you can use civix export]

   - Support->Developer->Api explorer v4
   - Entity = OptionGroup, Action = Export
   - enter id of option group
   - Execute
   - View as php
3. insert into code:

   - create `managed` folder
- create suitably named file `managed/my_option_group.mgd.php` [the usual convention is to use the name of the exported option group `OptionGroup_my_option_group` but you can call it what you like]
   - paste exported php code into the file (add opening php tag, and `use CRM_Myextension_ExtensionUtil as E;` at top of file)
- add `field` tag to xml/schema/CRM/myentity/MyEntity.xml
4. apply the changes

   - `civix generate:entity-boilerplate`

   - `cv flush`



Example managed option group file contents:

```php
<?php
    
use CRM_Myextension_ExtensionUtil as E;
    
return [
  [
    'name' => 'OptionGroup_my_option_group',
    'entity' => 'OptionGroup',
    'cleanup' => 'unused',
    'update' => 'unmodified',
    'params' => [
      'version' => 4,
      'values' => [
        'name' => 'my_option_group',
        'title' => E::ts('My option group'),
        'description' => E::ts('My option group - description'),
        'data_type' => 'String',
        'is_reserved' => FALSE,
        'is_active' => TRUE,
        'is_locked' => FALSE,
        'option_value_fields' => [
          'name',
          'label',
          'description',
        ],
      ],
      'match' => [
        'name',
      ],
    ],
  ],
  [
    'name' => 'OptionGroup_my_option_group_OptionValue_My_option_1',
    'entity' => 'OptionValue',
    'cleanup' => 'unused',
    'update' => 'unmodified',
    'params' => [
      'version' => 4,
      'values' => [
        'option_group_id.name' => 'my_option_group',
        'label' => E::ts('My option 1'),
        'value' => '1',
        'name' => 'My option 1',
        'grouping' => NULL,
        'filter' => 0,
        'is_default' => FALSE,
        'description' => E::ts('<p>This is the first option</p>'),
        'is_optgroup' => FALSE,
        'is_reserved' => FALSE,
        'is_active' => TRUE,
        'component_id' => NULL,
        'domain_id' => NULL,
        'visibility_id' => NULL,
        'icon' => NULL,
        'color' => NULL,
      ],
      'match' => [
        'name',
        'option_group_id',
      ],
    ],
  ],
  [
    'name' => 'OptionGroup_my_option_group_OptionValue_My_option_2',
    'entity' => 'OptionValue',
    'cleanup' => 'unused',
    'update' => 'unmodified',
    'params' => [
      'version' => 4,
      'values' => [
        'option_group_id.name' => 'my_option_group',
        'label' => E::ts('My option 2'),
        'value' => '2',
        'name' => 'My option 2',
        'grouping' => NULL,
        'filter' => 0,
        'is_default' => FALSE,
        'description' => E::ts('<p>This is the second option</p>'),
        'is_optgroup' => FALSE,
        'is_reserved' => FALSE,
        'is_active' => TRUE,
        'component_id' => NULL,
        'domain_id' => NULL,
        'visibility_id' => NULL,
        'icon' => NULL,
        'color' => NULL,
      ],
      'match' => [
        'name',
        'option_group_id',
      ],
    ],
  ],
];
```

Example of `field` tag making one-to-many link to option group:

```xml
  <field>
    <name>my_option_value</name>
    <title>My option value</title>
    <type>int unsigned</type>
    <required>true</required>
    <default>1</default>
    <comment>valid value, from my option group</comment>
    <pseudoconstant>
      <optionGroupName>my_option_group</optionGroupName>
    </pseudoconstant>
    <html>
      <type>Select</type>
      <label>My option</label>
    </html>
  </field>
```

**Important note:** the value of `optionGroupName` is the value of `'params'=>'values'=>'name'` in the mgd file. So, in the above example, not `OptionGroup_my_option_group`, but `my_option_group`.



### Creating a packaged search

1. Create a Search Kit search via the UI - including displays as required [for job ads I created separate displays for admin and contact tab]

2. Export with API UI [in Voscur I have to do this manually because it's an older version, but in latest Civi you can use civix export]

   - Support->Developer->Api explorer v4
   - Entity = SavedSearch, Action = Export
   - enter id of saved search
   - Execute
   - View as php

3. insert into code:

   - create `managed` folder, if not already 

   - create suitably named file `managed/my_saved_search.mgd.php` [the usual convention is to use the name of the exported option group `SavedSearch_my_saved_search` but you can call it what you like - *check this* - definitely true for option groups but saved searches?]

   - paste exported php code into the file (add opening php tag, and `use CRM_Myextension_ExtensionUtil as E;` at top of file)

4. apply the changes

   - `civix generate:entity-boilerplate`

   - `cv flush`



### Checking our work

Did it work? This is where we need to understand the relationship between what is defined via the UI and what is defined by managed entities in our extension.

Before we added our saved search and/or option groups to the extension, we could see them in the UI, where we initially created them. At this stage - when they have been defined in the UI but not in the extension - searches and option groups are saved in the CiviCRM database only.

Now we have defined them in our extension, this should mean that the option groups and search(es) we see in the UI are being added from the extension. 



## Create a search form

## Create a submission form

## Create a navigation link





