# Components of an extension

covered here: https://docs.civicrm.org/dev/en/latest/extensions/structure/

To get a better understanding of what these components are, let's put them in the order they are created, when creating a CRUD entity...

## The basic framework

`civix generate:module myextension` 

Creates:

- **info.xml**
- **myextension.php**
- **myextension.civix.php**
- **README.md**
- **LICENSE.txt**
- *build*
- *CRM/MyExtension*
- **images/screenshot.jpg**
- *templates*
- *xml*

Note that the folders created here are mostly empty (italics).

This could be a good time to update a few things in [info.xml](https://docs.civicrm.org/dev/en/latest/extensions/info-xml/) - name, description and author of the extension.



## The entity

`civix generate:entity MyEntity`

Updates:

- info.xml - adds entity-types 'mixin'

Creates:

- *api/v3*
- **Civi/Api4/Myentity.php**
- **CRM/Myentity/BAO/Myentity.php**
- *CRM/Myentity/DAO*
- **tests/phpunit/bootstrap.php**
- *tests/phpunit/api/v3*
- **xml/schema/CRM/Myentity/Myentity.entityType.php**
- **xml/schema/CRM/Myentity/Myentity.xml**

At this point it would be typical to make some manual changes to `xml/schema/CRM/Myentity/Myentity.xml`, which is the file that declares/defines the structure of your entity. This is for the most part a declaration of the structure and properties of the SQL table that will be used to store your entity items. So the root tag is 'table', and that contains tags like 'name' (the name the table will be given in SQL), a couple of 'field' tags, and tags defining primary keys, foreign keys. In the initial form generated by civix, there are just two field tags, one for the id of this entity and one for contact id. Also primary key, defined as the id, and foreign key, linking the contact id field to the civicrm_contact table (note the primaryKey and foreignKey tags are not nested but placed next to the fields they relate to). Of course these two 'starter' fields aren't of any great use on their own, and that's why you would normally add some new fields at this stage.

For **one-to-one** data, which will be stored in the same table, you add these as `<field>` tags, fully defined here in MyEntity.xml, but for **one-to-many** [and many-to-many?] the standard/default method is to first define an Option Group via the CiviCRM interface (under Administer->System Settings), then use the generated name of that option group in the field definition. More about this below, under 'Define an option group'.

Example of one-to-one data definition:

```xml
  <field>
    <name>description</name>
    <title>Full description</title>
    <type>longtext</type>
    <comment>Full description</comment>
    <html>
      <type>RichTextEditor</type>
      <rows>8</rows>
      <cols>60</cols>
    </html>
  </field>
```





## The entity boilerplate

`civix generate:entity-boilerplate`

Creates:

- **CRM/Myentity/DAO/JobAd.php** - this is your extension's local implementation of CiviCRM's core data access object (DAO) class(es) https://docs.civicrm.org/dev/en/latest/framework/codebase/#dao
- **sql/auto_install.sql** - https://docs.civicrm.org/dev/en/latest/framework/codebase/#sql
- **sql/auto_uninstall.sql**

[NB Civix will report having written to myentity.civix.php but don't be misled - this file hasn't been changed, but has been re-written the same as before. Civix re-writes this file every time]

Civix will point out you don't have an upgrader class.



## The upgrader class

`civix generate:upgrader`

Updates:

- info.xml - adds `<upgrader>CRM_Myentity_Upgrader</upgrader>`

Creates:

- **CRM/Myentity/Upgrader.php**

https://docs.civicrm.org/dev/en/latest/step-by-step/create-entity/#5-add-upgrader-class

"We need an upgrader class so that upon installation and uninstallation of our extension the files `auto_install.sql` and `auto_unsinstall.sql` are executed."

Now everything is in place, and we can install the extension, with `cv en myentity`. Now if we check the extensions page we'll see that the extension is installed (it would have already been listed, but not installed). We'll also find that there is a table civicrm_myentity in our database, and that Myentity is available in the APIv4 UI. We can now use the API UI to `create` a record in the civicrm_myentity table, then `get`, `delete` etc.

 

[at this stage we can make a SK search for our entity, and note there will be update and delete paths available when we make a table display... ]

[add and update paths - these are (or can be) added manually to xml/schema/CRM/Myentity/MyEntity.xml, and then they appear in CRM/Myentity/DAO/MyEntity.php - but is that neccessary? I did that for jobads, but in 'foo' they have appeared automatically at some stage (?) And the delete path? I had trouble with that in JobAds, but it seems to have appeared automatically in the UI for foo, but is not defined in either of these files (!?)]



## Install the extension

`cv en myentity`



Now we should see the following effects in the UI:

- the new extension appears as 'Enabled' under Administration->Customise Data & Screens->Extensions [is this the normal location?]
- the entity can be found in Api Explorer
- you can use the Api Explorer to perform CRUD actions on the entity
  - when you Create and Update, you'll see the fields as you defined in myentity.xml




If we are creating a new entity, we've just followed the first iteration of a cycle:

1) update entity schema 
2) generate boilerplate 
3) generate upgrader
4) (re-)install

This cycle will be repeated for any subsequent changes to the entity schema. [actually only the first two - just those followed by cv flush will do it]



What next? Whilst we can now perform CRUD actions through the API UI, that's not very user-friendly - only really suitable for advanced CiviCRM users. What we want now is to build into our extension some bespoke CRUD components suitable for non-technical users:

- searches and displays to view our entity data
- forms to create and update entity data

We might want different versions of these components for different users and different contexts:

- a search display a contact summary tab, showing data related to that contact only
- an admin front end
- public facing views

We might want to add some navigation links to appear in the Civi interface.

We will also want to ensure that our extension is properly self-contained and portable - all its components and dependencies are defined within the extension.



## Define some 'managed entities'

Managed Entity is a general concept, but in the scope of this document there are two particular sorts of managed entity that will interest us. These are, in no particular order, saved searches, and option groups.

Saved searches and option groups, as examples of managed entities, are created in a very similar way. Note your extension can define option groups but no saved search(es), or a saved search and no option groups. Saved searches and Option Groups are two independent varieties of managed entity.

The basic workflow for creating managed entities is:  

1. create in UI
2. export code
3. insert code in extension
4. flush caches



### Defining an option group

1. Create an option group via the UI.
2. Export with API UI [in Voscur I have to do this manually because it's an older version, but in latest Civi you can use civix export]

   - Support->Developer->Api explorer v4
   - Entity = OptionGroup, Action = Export
   - enter id of option group
   - Execute
   - View as php
3. insert into code:

   - create `managed` folder
- create suitably named file `managed/my_option_group.mgd.php` [the usual convention is to use the name of the exported option group `OptionGroup_my_option_group` but you can call it what you like]
   - paste exported php code into the file (add opening php tag, and `use CRM_Myextension_ExtensionUtil as E;` at top of file)
- add `field` tag to xml/schema/CRM/myentity/MyEntity.xml
4. apply the changes

   - `civix generate:entity-boilerplate`

   - `cv flush`



Example managed option group file contents:

```php
<?php
    
use CRM_Myextension_ExtensionUtil as E;
    
return [
  [
    'name' => 'OptionGroup_my_option_group',
    'entity' => 'OptionGroup',
    'cleanup' => 'unused',
    'update' => 'unmodified',
    'params' => [
      'version' => 4,
      'values' => [
        'name' => 'my_option_group',
        'title' => E::ts('My option group'),
        'description' => E::ts('My option group - description'),
        'data_type' => 'String',
        'is_reserved' => FALSE,
        'is_active' => TRUE,
        'is_locked' => FALSE,
        'option_value_fields' => [
          'name',
          'label',
          'description',
        ],
      ],
      'match' => [
        'name',
      ],
    ],
  ],
  [
    'name' => 'OptionGroup_my_option_group_OptionValue_My_option_1',
    'entity' => 'OptionValue',
    'cleanup' => 'unused',
    'update' => 'unmodified',
    'params' => [
      'version' => 4,
      'values' => [
        'option_group_id.name' => 'my_option_group',
        'label' => E::ts('My option 1'),
        'value' => '1',
        'name' => 'My option 1',
        'grouping' => NULL,
        'filter' => 0,
        'is_default' => FALSE,
        'description' => E::ts('<p>This is the first option</p>'),
        'is_optgroup' => FALSE,
        'is_reserved' => FALSE,
        'is_active' => TRUE,
        'component_id' => NULL,
        'domain_id' => NULL,
        'visibility_id' => NULL,
        'icon' => NULL,
        'color' => NULL,
      ],
      'match' => [
        'name',
        'option_group_id',
      ],
    ],
  ],
  [
    'name' => 'OptionGroup_my_option_group_OptionValue_My_option_2',
    'entity' => 'OptionValue',
    'cleanup' => 'unused',
    'update' => 'unmodified',
    'params' => [
      'version' => 4,
      'values' => [
        'option_group_id.name' => 'my_option_group',
        'label' => E::ts('My option 2'),
        'value' => '2',
        'name' => 'My option 2',
        'grouping' => NULL,
        'filter' => 0,
        'is_default' => FALSE,
        'description' => E::ts('<p>This is the second option</p>'),
        'is_optgroup' => FALSE,
        'is_reserved' => FALSE,
        'is_active' => TRUE,
        'component_id' => NULL,
        'domain_id' => NULL,
        'visibility_id' => NULL,
        'icon' => NULL,
        'color' => NULL,
      ],
      'match' => [
        'name',
        'option_group_id',
      ],
    ],
  ],
];
```

Example of `field` tag making one-to-many link to option group:

```xml
  <field>
    <name>my_option_value</name>
    <title>My option value</title>
    <type>int unsigned</type>
    <required>true</required>
    <default>1</default>
    <comment>valid value, from my option group</comment>
    <pseudoconstant>
      <optionGroupName>my_option_group</optionGroupName>
    </pseudoconstant>
    <html>
      <type>Select</type>
      <label>My option</label>
    </html>
  </field>
```

**Important note:** the value of `optionGroupName` is the value of `'params'=>'values'=>'name'` in the mgd file. So, in the above example, not `OptionGroup_my_option_group`, but `my_option_group`.



### Creating a packaged search

1. Create a Search Kit search via the UI - including displays as required [for job ads I created separate displays for admin and contact tab]

2. Export with API UI [in Voscur I have to do this manually because it's an older version, but in latest Civi you can use civix export]

   - Support->Developer->Api explorer v4
   - Entity = SavedSearch, Action = Export
   - enter id of saved search
   - Execute
   - View as php

3. insert into code:

   - create `managed` folder, if not already 

   - create suitably named file `managed/my_saved_search.mgd.php` [the usual convention is to use the name of the exported option group `SavedSearch_my_saved_search` but you can call it what you like - *check this* - definitely true for option groups but saved searches?]

   - paste exported php code into the file (add opening php tag, and `use CRM_Myextension_ExtensionUtil as E;` at top of file)

4. apply the changes

   - `civix generate:entity-boilerplate`

   - `cv flush`



### Create a navigation link

1. create a navigation link via the UI `Administer->Customise Data and Screens->Navigation Menu`

2. Export with API UI

   - Support->Developer->Api explorer v4

   - Entity = Navigation, Action = Export

   - enter id of navigation link [not easy to do via the UI - I could only do it by inspecting the html. Can also be found in table `civicrm_navigation`]

   - Execute

   - View as php

3. insert into code:

   - create `managed` folder, if not already 

   - create suitably named file `managed/my_navigation.mgd.php` 

   - paste exported php code into the file (add opening php tag, and `use CRM_Myextension_ExtensionUtil as E;` at top of file)

4. apply the changes

   - `civix generate:entity-boilerplate`

   - `cv flush`



### Checking our work

Did it work? This is where we need to understand the relationship between what is defined via the UI and what is defined by managed entities in our extension.

Before we added our saved search and/or option groups to the extension, we could see them in the UI, where we initially created them. At this stage - when they have been defined in the UI but not in the extension - searches and option groups are saved in the CiviCRM database only.

Now we have defined them in our extension, this should mean that the option groups and search(es) we see in the UI are being added from the extension.  

For a packaged search, we can verify this in the UI. In the SearchKit home page, our search has moved from 'Custom Searches' tab to 'Packaged Search', with the 'Package' shown as 'My Entity Name' (from info.xml).

In the database the search has been added to `civicrm_saved_search`

For an option group, hmm... there's nothing in the UI that shows the origin of option groups. That's because (I reckon) the listing of option groups is built from the table `civicrm_option_group`, which is an older table that predates SK etc. [is there a reason this hasn't been tackled in AdminUI?] However there is a table `civicrm_managed` which keeps track of all managed entities. That's where we can see all our managed entity components: option groups, option values, saved searches, and others [distinct values: CustomField, CustomGroup, CustomSearch, Job, Navigation, OptionGroup, OptionValue, PaymentProcessorType, RelationshipType, ReportTemplate, SavedSearch, SearchDisplay]

...in all cases the nuclear option is to delete from UI then regenerating boilerplate...



## Create a user interface (with Form Builder)

We want to be able to CRUD our entity objects. We can do it via the API UI, but that's very techie. We *could* do it with a SearchKit display, but that would only get us so far. For a self-contained/release-able extension we'll need something more usable for non-technical users - an admin interface in the backend, and perhaps something public-facing.

For this we need to create some forms in Form Builder. As with managed entities, to add FB forms to an extension, there's a similar workflow of creating via the UI then exporting to code.

Following the standard master/detail CRUD pattern, i.e. a listing of our entity objects, with a means to create a new one, and read, update or delete existing ones.

Something that's a bit confusing here - CRUD links don't get created automatically but have to be added to the schema. See: https://docs.civicrm.org/dev/en/latest/step-by-step/create-entity/#8-integration-with-search-kit

...but some do seem to arrive automatically sometimes - I've noticed some inconsistency e.g. whether or not a delete path is created, and I don't really understand why... probably to do with Civi version - did I use civix?

https://modeler.cloud.camunda.io/diagrams/f769e7b8-af24-4892-8e53-07eb99591eb7--extension-v2?v=921,392,1

### Create a master list with a FB search form

Before getting into CRUD functionality, let's just say we want a searchable/filterable master listing. How do we do that?

The workflow:

1. create a *search* in SearchKit
2. create a SK *[display](https://docs.civicrm.org/dev/en/latest/searchkit/displays/)* from the search
3. create a FB *form* from the display
4. export to code
   - expose to afform https://docs.civicrm.org/dev/en/latest/afform/form-builder/#via-declaration-file
     - add mixin to info.xml
     - create `afformEntities` folder and file MyEntity.php 
     - [now the entity type will appear in some new places in UI e.g. in the New Submission Form drop down]
   - export the form https://docs.civicrm.org/dev/en/latest/afform/afform-core/
     - create `ang` folder
     - [...this looks a bit nightmarish...]
     - [...ah no not quite as bad as I thought, because you can copy paste the markup for the form from the FB UI... that's the aff.html file]
     - [...but then the json/php file is another matter... in the documentation it's a json file, but looks like the current best practice is to use a php file - that's what civix makes anyway...]

a great deal of this workflow is now replaced with civix export in newer Civi versions, but still worth knowing - because it's worth knowing what civix export is doing, and why...





### 'Create' via a submission form

### 'Read'

### 'Update'

### 'Delete'

