# How to build an extension

*This is intended as an update of the old step-by-step guide here: https://docs.civicrm.org/dev/en/latest/step-by-step/create-entity/*

*For reference, the structure of extensions is documented here: https://docs.civicrm.org/dev/en/latest/extensions/structure/*

*Arguably the material here is already out of date with the advent of ECK, but I think it's always useful to know what's going on under the hood.* 

*To follow this guide you need a working CiviCRM install, and an understanding of buildkit components civix and cv. That can be a mission in itself for a beginner - covered here: https://docs.civicrm.org/dev/en/latest/tools/buildkit/. Personally I use a Docker implementation. [That could be the subject of another piece...]*



## Creating a basic extension framework

Navigate to the extensions directory of your CiviCRM install and run:

`civix generate:module myextension` 

This creates folder myextension, containing these files and folders:

- **info.xml**
- **myextension.php**
- **myextension.civix.php**
- **README.md**
- **LICENSE.txt**
- *build*
- *CRM/MyExtension*
- **images/screenshot.jpg**
- *templates*
- *xml*

Note that the folders created here are mostly empty (italics = empty folder, bold = generated files/folders).

At this point you might want to update a few things in [info.xml](https://docs.civicrm.org/dev/en/latest/extensions/info-xml/) - e.g. the name, description and author of the extension. 



## Create an entity

It is quite likely (but not inevitable) that you will want to create an *entity* within your extension. If your extension is going to model some real-world thing that isn't already represented in the CiviCRM database, then you'll be wanting to create an entity.

`cd` into your *myextension* folder and run:

 `civix generate:entity MyEntity`

This updates:

- info.xml - adds `<mixin>entity-types-php@1.0.0</mixin>`

...and creates:

- *api/v3*
- **Civi/Api4/Myentity.php**
- **CRM/Myentity/BAO/Myentity.php**
- *CRM/Myentity/DAO*
- **tests/phpunit/bootstrap.php**
- *tests/phpunit/api/v3*
- **xml/schema/CRM/Myentity/Myentity.entityType.php**
- **xml/schema/CRM/Myentity/Myentity.xml**

At this point it would be typical to make some manual changes to `xml/schema/CRM/Myentity/Myentity.xml`, which is the file that declares/defines the structure of your entity. This is for the most part a declaration of the structure and properties of the SQL table that will be used to store your entity items. So the root tag is 'table', and that contains tags like 'name' (the name the table will be given in SQL), some number of 'field' tags, and, potentially, tags defining primary keys, foreign keys, indexes etc. 

In the initial file generated by civix, there are (1) two field tags, one for the id of this entity and one for contact id (it is assumed that any entity declared in CiviCRM will be connected to a contact, but that isn't *necessarily* true), (2) a primary key, defined on the id, and a foreign key linking the contact id field to the civicrm_contact table (note the primaryKey and foreignKey tags are not nested but placed next to the fields they relate to). 

Of course these two 'starter' fields aren't of any great use on their own, and that's why you would normally add some new fields at this stage.

As a general guide for adding fields, for **one-to-one** data, which will be stored in the same database table, you add these as `<field>` tags, fully defined here in your MyEntity.xml file, something like this:

```xml
  <field>
    <name>description</name>
    <title>Full description</title>
    <type>longtext</type>
    <comment>Full description</comment>
    <html>
      <type>RichTextEditor</type>
      <rows>8</rows>
      <cols>60</cols>
    </html>
  </field>
```

For **one-to-many** data the standard/default method is to refer to a separate *Option Group*. 

Option Groups are defined via two tables in the core CiviCRM database: civicrm_option_group and civicrm_option_value. You might want to refer to an existing option group, or you might want to define your own via the CiviCRM interface (under Administer->System Settings), then use the generated name of that option group in the field definition. More about this below, under 'Define an option group'.



## Generate entity boilerplate

Now that you've defined the form of your entity, you need to generate some boilerplate code that will allow CiviCRM to find and interact with that entity.

Run:

`civix generate:entity-boilerplate`

Creates:

- **CRM/Myentity/DAO/JobAd.php** - this is your extension's local implementation of CiviCRM's core data access object (DAO) class(es) https://docs.civicrm.org/dev/en/latest/framework/codebase/#dao
- **sql/auto_install.sql** - the sql that creates your table https://docs.civicrm.org/dev/en/latest/framework/codebase/#sql
- **sql/auto_uninstall.sql** - the sql that removes your table

[NB Civix will report having written to myentity.civix.php but don't be misled - this file hasn't been changed, but has been re-written the same as before. Civix re-writes this file every time]

Civix will point out you don't have an upgrader class, so the next step is to generate that...



## Generate the upgrader class

`civix generate:upgrader`

Updates:

- info.xml - adds `<upgrader>CRM_Myentity_Upgrader</upgrader>`

Creates:

- **CRM/Myentity/Upgrader.php**

https://docs.civicrm.org/dev/en/latest/step-by-step/create-entity/#5-add-upgrader-class

"We need an upgrader class so that upon installation and uninstallation of our extension the files `auto_install.sql` and `auto_unsinstall.sql` are executed."

You only need to create the upgrader class once. Once created, it doesn't need updating.



## Install the extension

Now everything is in place, and we can *install* the extension.

We run `cv en myentity`. This won't produce any changes in code, but it will (1) create the table civicrm_myentity in the database, and (2) expose the extension in various places in the CiviCRM UI:

- in the CiviCRM extensions page Administration->Customise Data & Screens->Extensions the extension is now *installed* (it would have already been listed, but not installed)
- the entity can be found in Api Explorer
- you can use the Api Explorer to perform CRUD actions on the entity
  - when you Create and Update, you'll see the fields as you defined in myentity.xml
- we can make a SearchKit search for our entity
- we can make a SearchKit display from our search, and there will be update and delete paths available

[add and update paths - these are (or can be) added manually to xml/schema/CRM/Myentity/MyEntity.xml, and then they appear in CRM/Myentity/DAO/MyEntity.php - but is that neccessary? I did that for jobads, but in 'foo' they have appeared automatically at some stage (?) And the delete path? I had trouble with that in JobAds, but it seems to have appeared automatically in the UI for foo, but is not defined in either of these files (!?)]





## Updating the entity

At this point it's likely you might want to make some changes or additions to the structure of your entity. 

To do that, just repeat the steps outlined above. What we've done in *creating* the entity is follow the first iteration of a cycle, which is repeated for any future changes:

1) update entity schema 
2) generate boilerplate 
3) [generate upgrader - this is only done once, when the entity is first created]
4) (re-)install the extension
5) flush caches with `cv flush`

This cycle will be repeated for any subsequent changes to the entity schema.

Note that you need to re-install the extension to apply changes to the entity that require an sql update. For most other extension changes it is only necessary to flush the caches. More on this below.



## What next?

Beyond this point we might follow a few different paths, depending on the functionality that we need in our extension. 

If we've created an entity, then we are going to need some variety of CRUD interface - possibly more than one if we are catering to different audiences i.e. back-end admin vs public facing.

As noted above we can already perform CRUD actions through the API UI, but that's not very user-friendly, and only really suitable for advanced CiviCRM users. What we want now is to build into our extension some bespoke CRUD components suitable for non-technical users:

- searches and displays to view our entity data
- forms to create and update entity data
- safe ways to delete data

We might want different versions of these components for different users and different contexts:

- a search display a contact summary tab, showing data related to that contact only
- an admin front end
- public facing views

We might want to add some navigation links to appear in the Civi interface.

We will also want to ensure that our extension is properly self-contained and portable - with all its components and dependencies defined within the extension.



Broadly speaking, we'll use *Managed Entities* to create the basic underpinnings, and *Form Builder* to create a user-interaction layer. 



## Define some 'managed entities'

The *Managed Entity* is a general concept in CiviCRM, but in the scope of this document there are two particular sorts of managed entity that will interest us. These are, in no particular order, saved searches, and option groups. [...and navigation]

Saved searches and option groups, as examples of managed entities, are both created in a similar way. Note Saved searches and Option Groups are two *independent* varieties of managed entity. Your extension can define option groups but no saved search(es), or a saved search and no option groups. 

The basic workflow for creating managed entities is:  

1. create in UI
2. export code
3. insert code in extension
4. flush caches



### Defining an option group

If we want our entity to have any one-to-many data relationships, the standard mechanism is to use an Option Group. 

Option Groups are defined via two tables in the core CiviCRM database: civicrm_option_group and civicrm_option_value. In your new entity you might refer to an existing option group, or you might want to define your own via the CiviCRM interface (under Administer->System Settings) and incorporate that option group definition into your extension as a manged entity.

These are the steps:

1. Create an option group via the UI.
2. Export with API UI [in latest versions of CiviCRM you can replace these steps with civix export]

   - Support->Developer->Api explorer v4
   - Entity = OptionGroup, Action = Export
   - enter id of option group
   - Execute
   - View as php and copy to clipboard
3. insert into code:

   - create `managed` folder
   
   - create suitably named file `managed/my_option_group.mgd.php` [the usual convention is to use the name of the exported option group `OptionGroup_my_option_group` but you can call it what you like]
   - paste exported php code into the file (add opening php tag, and `use CRM_Myextension_ExtensionUtil as E;` at top of file)
   - add `field` tag to xml/schema/CRM/myentity/MyEntity.xml
4. apply the changes

   - `civix generate:entity-boilerplate`

   - `cv flush`



Example managed option group file contents:

```php
<?php
    
use CRM_Myextension_ExtensionUtil as E;
    
return [
  [
    'name' => 'OptionGroup_my_option_group',
    'entity' => 'OptionGroup',
    'cleanup' => 'unused',
    'update' => 'unmodified',
    'params' => [
      'version' => 4,
      'values' => [
        'name' => 'my_option_group',
        'title' => E::ts('My option group'),
        'description' => E::ts('My option group - description'),
        'data_type' => 'String',
        'is_reserved' => FALSE,
        'is_active' => TRUE,
        'is_locked' => FALSE,
        'option_value_fields' => [
          'name',
          'label',
          'description',
        ],
      ],
      'match' => [
        'name',
      ],
    ],
  ],
  [
    'name' => 'OptionGroup_my_option_group_OptionValue_My_option_1',
    'entity' => 'OptionValue',
    'cleanup' => 'unused',
    'update' => 'unmodified',
    'params' => [
      'version' => 4,
      'values' => [
        'option_group_id.name' => 'my_option_group',
        'label' => E::ts('My option 1'),
        'value' => '1',
        'name' => 'My option 1',
        'grouping' => NULL,
        'filter' => 0,
        'is_default' => FALSE,
        'description' => E::ts('<p>This is the first option</p>'),
        'is_optgroup' => FALSE,
        'is_reserved' => FALSE,
        'is_active' => TRUE,
        'component_id' => NULL,
        'domain_id' => NULL,
        'visibility_id' => NULL,
        'icon' => NULL,
        'color' => NULL,
      ],
      'match' => [
        'name',
        'option_group_id',
      ],
    ],
  ],
  [
    'name' => 'OptionGroup_my_option_group_OptionValue_My_option_2',
    'entity' => 'OptionValue',
    'cleanup' => 'unused',
    'update' => 'unmodified',
    'params' => [
      'version' => 4,
      'values' => [
        'option_group_id.name' => 'my_option_group',
        'label' => E::ts('My option 2'),
        'value' => '2',
        'name' => 'My option 2',
        'grouping' => NULL,
        'filter' => 0,
        'is_default' => FALSE,
        'description' => E::ts('<p>This is the second option</p>'),
        'is_optgroup' => FALSE,
        'is_reserved' => FALSE,
        'is_active' => TRUE,
        'component_id' => NULL,
        'domain_id' => NULL,
        'visibility_id' => NULL,
        'icon' => NULL,
        'color' => NULL,
      ],
      'match' => [
        'name',
        'option_group_id',
      ],
    ],
  ],
];
```

Example of `field` tag making one-to-many link to option group:

```xml
  <field>
    <name>my_option_value</name>
    <title>My option value</title>
    <type>int unsigned</type>
    <required>true</required>
    <default>1</default>
    <comment>valid value, from my option group</comment>
    <pseudoconstant>
      <optionGroupName>my_option_group</optionGroupName>
    </pseudoconstant>
    <html>
      <type>Select</type>
      <label>My option</label>
    </html>
  </field>
```

**Important note:** the value of `optionGroupName` is the value of `'params'=>'values'=>'name'` in the mgd file. So, in the above example, not `OptionGroup_my_option_group`, but `my_option_group`.



### Creating a packaged search

You probably want to offer a master list of your entity items, from which to select items to Read, Update or Delete.

1. Create a Search Kit search via the UI - including displays as required 

2. Export with API UI [in latest versions of CiviCRM you can replace these steps with civix export]

   - Support->Developer->Api explorer v4
   - Entity = SavedSearch, Action = Export
   - enter id of saved search
   - Execute
   - View as php

3. insert into code:

   - create `managed` folder, if you haven't already 

   - create suitably named file `managed/my_saved_search.mgd.php` - the usual convention is to use the name of the exported search e.g. `SavedSearch_my_saved_search` but you can call it what you like [*check this* - definitely true for option groups but saved searches?]

   - paste exported php code into the file (add opening php tag, and `use CRM_Myextension_ExtensionUtil as E;` at top of file)

4. apply the changes

   - `civix generate:entity-boilerplate`

   - `cv flush`



### Create a navigation link

1. create a navigation link via the UI `Administer->Customise Data and Screens->Navigation Menu`

2. Export with API UI

   - Support->Developer->Api explorer v4

   - Entity = Navigation, Action = Export

   - enter id of navigation link [not easy to do via the UI - I could only do it by inspecting the html. Can also be found in table `civicrm_navigation`]

   - Execute

   - View as php

3. insert into code:

   - create `managed` folder, if not already 

   - create suitably named file `managed/my_navigation.mgd.php` 

   - paste exported php code into the file (add opening php tag, and `use CRM_Myextension_ExtensionUtil as E;` at top of file)

4. apply the changes

   - `civix generate:entity-boilerplate`

   - `cv flush`



### Checking your work

Did it work? 

This is where we need to understand the relationship between what is defined via the UI and what is defined by managed entities in our extension.

Before we added our saved search and/or option groups to the extension, we could see them in the UI, where we initially created them. At that stage - when they have been defined in the UI but not in the extension - searches and option groups exist in the CiviCRM database only.

Now we have defined them in our extension, this should mean that the option groups and search(es) we see in the UI are being added from the extension.  

For a packaged search, we can verify this in the UI. In the SearchKit home page, our search has moved from 'Custom Searches' tab to 'Packaged Search', with the 'Package' shown as 'My Entity Name' (from info.xml).

In the database the search has been added to `civicrm_saved_search`

For an option group, hmm... there's nothing in the UI that shows the origin of option groups. That's because (I reckon) the listing of option groups is built from the table `civicrm_option_group`, which is an older table that predates SK etc. [is there a reason this hasn't been tackled in AdminUI?] However there is a table `civicrm_managed` which keeps track of all managed entities. That's where we can see all our managed entity components: option groups, option values, saved searches, and others [distinct values: CustomField, CustomGroup, CustomSearch, Job, Navigation, OptionGroup, OptionValue, PaymentProcessorType, RelationshipType, ReportTemplate, SavedSearch, SearchDisplay]

...in all cases the nuclear option is to delete from UI then regenerating boilerplate...



## Create a user interface (with Form Builder/afform)

*Note, 'Form Builder' (FB) and 'afform' can be considered synonymous. 'afform' is the name of the extension, in CiviCRM code. 'Form Builder' is the name it gets in the UI. I'm mostly using 'FB', but using 'afform' when talking about the internal workings of CiviCRM.*

We want to be able to CRUD our entity objects. We can do it via the API UI, but that's very techie. We *could* do it with a SearchKit display, but that would only get us so far. For a self-contained/release-able extension we'll need something more usable for non-technical users - an admin interface in the backend, and perhaps something public-facing.

For this we need to create some forms in Form Builder. As with managed entities, adding FB forms to an extension has a similar workflow of creating via the UI then exporting to code.

Following the standard master/detail CRUD pattern, i.e. a listing of our entity objects, with a means to create a new one, and read, update or delete existing ones.

Something that's a bit confusing here - CRUD links don't get created automatically but have to be added to the schema. See: https://docs.civicrm.org/dev/en/latest/step-by-step/create-entity/#8-integration-with-search-kit

...but some do seem to arrive automatically sometimes - I've noticed some inconsistency e.g. whether or not a delete path is created, and I don't really understand why... probably to do with Civi version - did I use civix?

https://modeler.cloud.camunda.io/diagrams/f769e7b8-af24-4892-8e53-07eb99591eb7--extension-v2?v=921,392,1

### Create a master list with a FB search form

Before getting into CRUD functionality, let's just say we want a searchable/filterable master listing. How do we do that?

As a preliminary to adding any FB features into our extension, we need to make the extension visible to afform, or 'expose' it to afform https://docs.civicrm.org/dev/en/latest/afform/form-builder/#via-declaration-file:

- add mixin to info.xml `<mixin>afform-entity-php@1.0.0</mixin>`
- create `afformEntities` folder, containing file MyEntity.php 

The absolute minimum that afformEntities/MyEntity.php must do, to avoid an error, is return an empty array, but for our purposes here we need:

```php
<?php

use CRM_MyExtension_ExtensionUtil as E;

return [
   'type' => 'primary',
   'defaults' => "{}",
];
```

Returning `'type' => 'primary'` makes our entity appear in the 'New Submission Form' drop down in Form Builder UI [but without an icon...]

[what does `defaults => "{}"` do?]



The workflow:

1. create a *search* in SearchKit
2. create a SK *[display](https://docs.civicrm.org/dev/en/latest/searchkit/displays/)* from the search
3. create a FB *form* from the display
4. export the form to code https://docs.civicrm.org/dev/en/latest/afform/afform-core/:
   - create `ang` folder
   - create aff.html file and paste in markup exported from FB
   - create aff.json file - the very least this file must do is return a server route [and a title?]
5. cv flush

[note, a great deal of this workflow is now replaced with civix export in newer Civi versions, but still worth knowing - because it's worth knowing what civix export is doing, and why...]

Now this search form will appear under 'System Forms' tab in the FB UI home page [and so we can delete the one that's still in the Search forms tab? I think no, because there's no way to edit the system form via the UI, and it's a lot easier to do it that way than work directly in code]

ah - if I add `"type": "search"` to the aff.json file the form now appears under Search Forms, and can now be edited (but not deleted)

[what's difference between having aff.php compared with aff.json? Civix export creates a hp file that returns an array. The keys of this array correspond to values that can be used in aff.json, but (1) when I manually created such a php file it didn't get picked up (perhaps a version issue) (2) the 'icon' key doesn't work]

### 'Create' via a submission form

Next let's add a form for creating entity objects...

1. create a submission form
2. export to code



Tip: you need this in the schema:

```php
    <html>
      <type>EntityRef</type>
      <label>Contact</label>
    </html>
```



### 'Read'

### 'Update'

### 'Delete'

## Add contact summary tab
